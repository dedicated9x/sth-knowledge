# -*- coding: utf-8 -*-
"""week2_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1juv5Vw9EvjGJwP7q2c4PUEsRJXXlcdxx
"""

#import matplotlib 3d plotting
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib notebook
import numpy as np
#computing the numerical gradient of sin(xy)
#
#define a grid of points

#h = 0.001#step
#xs = -1 + np.array(range(0,(int)(1/h))) * 2 * h
#ys = -1 + np.array(range(0,(int)(1/h))) * 2 * h
nrpts = 101
xs = np.linspace(-3, 3, num = nrpts)
ys = np.linspace(-3, 3, num = nrpts)
xs = xs.reshape( (nrpts,1) )
ys = ys.reshape( (1, nrpts) )
h = 1. / nrpts

gradx = (np.sin( (xs +h).dot(ys) ) - np.sin( xs.dot(ys) ) ) / h
grady = (np.sin( xs.dot( ys +h) ) - np.sin( xs.dot(ys) ) ) / h

# z1 = xs.dot(ys)
# z2 = np.matmul(xs, ys)
# z3 = xs @ ys


print(gradx)
#compare with analytic gradient
agradx = np.cos(xs.dot(ys))
for i in range((int)(nrpts)):
    agradx[:,i] = agradx[:,i] * ys[0,i]
agrady = np.cos(xs.dot(ys))
#for i in range((int)(1/h)):

xsf = np.meshgrid(xs, ys)[0]
ysf = np.meshgrid(xs, ys)[1]
#plotting the x component of the gradient
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(xsf, ysf, gradx)
plt.show()

#compare with symbolic derivative
"""
grid = np.meshgrid(xs, ys)
symb = ysf * np.cos(grid)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(xsf, ysf, gradx)
plt.show()
"""

#plotting the y component of the gradient
"""
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(xsf, ysf, grady)
plt.show()
"""
#plotting gradients as vector field
nrpts = 21
xs = np.linspace(-2, 2, num = nrpts)
ys = np.linspace(-2, 2, num = nrpts)
xs = xs.reshape( (nrpts,1) )
ys = ys.reshape( (1, nrpts) )
h = 1. / nrpts

gradx = (np.sin( (xs +h).dot(ys) ) - np.sin( xs.dot(ys) ) ) / h #use list comprehension
grady = (np.sin( xs.dot( ys +h) ) - np.sin( xs.dot(ys) ) ) / h

fig, ax = plt.subplots()
# TODO 1
q = ax.quiver(xs, ys, gradx, grady)
# q = ax.quiver(xs, ys, 10*gradx, 10*grady)
#ax.quiverkey(q, X=0.3, Y=1.1, U=10,
#             label='Quiver key, length = 10', labelpos='E')

plt.show()

nrpts = 100
xs = np.linspace(-2, 2, num = nrpts)
ys = np.linspace(-2, 2, num = nrpts)
xs = xs.reshape( (nrpts,1) )
ys = ys.reshape( (1, nrpts) )
h = 1. / nrpts

gradx = (np.sin( (xs +h).dot(ys) ) - np.sin( xs.dot(ys) ) ) / h #use list comprehension
grady = (np.sin( xs.dot( ys +h) ) - np.sin( xs.dot(ys) ) ) / h


#plotting the gradient as heat map
#compute heatmap at each point for [gradx, grady]
heatmap = gradx*gradx + grady*grady
heatmap = heatmap / np.max(np.max(heatmap))

print(heatmap)
#'RdBu'
cmap = plt.get_cmap('YlGnBu')
fig, ax = plt.subplots()
xsf = np.meshgrid(xs, ys)[0]
ysf = np.meshgrid(xs, ys)[1]
im = ax.pcolormesh(xsf, ysf, heatmap, cmap=cmap )
fig.colorbar(im, ax=ax)
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib auto
#compute the numerical first and second derivative of sin(x) for a grid of points in the interval [0,2pi]

#grid of uniformly spaced points
pts = 100
h = 1./pts
xs = np.linspace(0, 2*np.pi, num = pts)
ys = (np.sin(xs+h) - np.sin(xs) ) / h #better call like this, than list comprehension
ys2 = (np.sin(xs+h) - 2*np.sin(xs) + np.sin(xs-h)) / h*h

plt.subplot(3, 1, 1)
plt.title('numerical derivative of sin(x)')
plt.plot(xs, ys)

plt.subplot(3, 1, 2)
plt.title('numerical second derivative of sin(x)')
plt.plot(xs, ys2)

plt.subplot(3, 1, 3)
plt.title('-sin(x)')
plt.plot(xs, -np.sin(xs))

plt.show()

